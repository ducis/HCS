/** ###################################################################
**     THIS BEAN MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename  : IEE1.C
**     Project   : Project_4
**     Processor : MC9S12XS128MAA
**     Beantype  : IntEEPROM
**     Version   : Bean 02.189, Driver 01.21, CPU db: 3.00.003
**     Compiler  : CodeWarrior HCS12X C Compiler
**     Date/Time : 2010-5-3, 23:16
**     Abstract  :
**         This device "IntEEPROM" implements internal EEPROM
**     Comment   :
**         The EEPROM array is organized as rows of word (2 bytes), the EEPROM block's
**         erase sector size is 2 rows (2 words). Therefore it is preferable
**         to use word aligned data for writting - methods SetWord and SetLong -
**         with word aligned address.
**         Driver expects that all security options of EEPROM are disabled.
**         If some security option is enabled methods performing write
**         operation (such as SetWord) can return error.
**     Settings  :
**         EEPROM size                 : 8192 byte
**         Initialization:
**              Wait in methods        : Enabled
**              EEPROM clock           : 1000 kHz
**
**     Contents  :
**         SetByte - byte IEE1_SetByte(IEE1_TAddress Addr, byte Data);
**         GetByte - byte IEE1_GetByte(IEE1_TAddress Addr, byte *Data);
**
**     (c) Copyright UNIS, a.s. 1997-2008
**     UNIS, a.s.
**     Jundrovska 33
**     624 00 Brno
**     Czech Republic
**     http      : www.processorexpert.com
**     mail      : info@processorexpert.com
** ###################################################################*/


/* MODULE IEE1. */

#include "IEE1.h"

#pragma DATA_SEG IEE1_DATA
#pragma CODE_SEG IEE1_CODE

#pragma MESSAGE DISABLE C12056

static word BackupArray[128];          /* Array for backup data from erased sector */

/*
** ===================================================================
**     Method      :  BackupSector (bean IntEEPROM)
**
**     Description :
**         The method backups the content of a sector being erased.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void BackupSector(IEE1_TAddress Addr, word From, word To)
{
  word i;

  for (i = From; i<To; i=i+2) {
    BackupArray[i/2] = *(word *far) (Addr + i/2); /* save one sector to RAM */
  }
}

/*
** ===================================================================
**     Method      :  WriteBlock (bean IntEEPROM)
**
**     Description :
**         The method writes the block of data to EEPROM memory.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static byte WriteBlock(IEE1_TAddress Addr, word From, word To, word* Data)
{
  byte err = 0;
  word i;
  byte j;
  dword PhraseAddr;

  if(From == To) {
    return ERR_OK;
  }
  i = From;
  PhraseAddr = (dword)Addr;
  while(i < To) {
  /* FSTAT: ACCERR=1,FPVIOL=1 */
    FSTAT = 48;                        /* Clear error flags */
    FCCOBIX = 0;                       /* Clear index register */
    FCCOBHI = 17;                      /* Program D-Flash command */
    FCCOBLO = (byte)(PhraseAddr >> 16); /* High address word */
    FCCOBIX++;                         /* Shift index register */
    FCCOB = (word)PhraseAddr;          /* Low address word */
    for(j = 0;j < 8;j+=2) {
      FCCOBIX++;                       /* Shift index register */
      FCCOB = *(word*)(Data + i/2);    /* Load new data */
      i+=2;
      if(i >= To) {break;}
    }
    FSTAT = 128;                       /* Clear flag command buffer empty */
    while (FSTAT_CCIF == 0);           /* Wait to command complete */
    if ((FSTAT_FPVIOL == 1) || (FSTAT_ACCERR == 1)) { /* Is protection violation or acces error detected ? */
      return ERR_NOTAVAIL;             /* If yes then error */
    }
    if (FSTAT_MGSTAT) {                /* Was attempt to write data to the given address errorneous? */
      err = 1;                         /* If yes then mark an error */
    }
    PhraseAddr +=8;
  }
  if(err) {
    return ERR_VALUE;                  /* If yes then error */
  }
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  EraseSectorInternal (bean IntEEPROM)
**
**     Description :
**         The method erase a specific sector.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static byte EraseSectorInternal(IEE1_TAddress Addr)
{
  if (FSTAT_CCIF == 0) {               /* Is command complete ? */
    return ERR_BUSY;                   /* If yes then error */
  }
  /* FSTAT: ACCERR=1,FPVIOL=1 */
  FSTAT = 48;                          /* Clear error flags */
  FCCOBIX = 0;                         /* Clear index register */
  FCCOBHI = 18;                        /* Erase D-Flash sector command */
  FCCOBLO = (byte)(((dword)Addr) >> 16); /* High address word */
  FCCOBIX++;                           /* Shift index register */
  FCCOB = (word)(((dword)Addr) & 4294967294L); /* Low address word aligned to word*/
  FSTAT = 128;                         /* Clear flag command buffer empty */
  while (FSTAT_CCIF == 0);             /* Wait to command complete */
  if (FSTAT_ACCERR || FSTAT_MGSTAT) {  /* Is access error or other error detected ? */
    return ERR_NOTAVAIL;               /* If yes then error */
  }
  return ERR_OK;                       /* OK */
}
/*
** ===================================================================
**     Method      :  WriteWord (bean IntEEPROM)
**
**     Description :
**         The method writes the word data to EEPROM memory.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static byte WriteWord(IEE1_TAddress AddrRow,word Data16)
{
  if (FSTAT_CCIF == 0) {               /* Is previous command in process ? */
    return ERR_BUSY;                   /* If yes then error */
  }
  /* FSTAT: ACCERR=1,FPVIOL=1 */
  FSTAT = 48;                          /* Clear error flags */
  FCCOBIX = 0;                         /* Clear index register */
  FCCOBHI = 17;                        /* Program D-Flash command */
  FCCOBLO = (byte)(((dword)AddrRow) >> 16); /* High address word */
  FCCOBIX++;                           /* Shift index register */
  FCCOB = (word)((dword)AddrRow);      /* Low address word */
  FCCOBIX++;                           /* Shift index register */
  FCCOB = Data16;                      /* Load new data */
  FSTAT = 128;                         /* Clear flag command complete */
  if ((FSTAT_FPVIOL == 1) || (FSTAT_ACCERR == 1)) { /* Is protection violation or acces error detected ? */
    return ERR_NOTAVAIL;               /* If yes then error */
  }
  while (!FSTAT_CCIF) {}               /* Wait for command completition */
  if (FSTAT_MGSTAT) {                  /* Was attempt to write data to the given address errorneous? */
    return ERR_VALUE;                  /* If yes then error */
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  IEE1_SetByte (bean IntEEPROM)
**
**     Description :
**         This method writes a given byte to a specified address in
**         EEPROM. The method also sets address pointer for <SetActByte>
**         and <GetActByte> methods (applicable only if these methods
**         are enabled). The pointer is set to address passed as the
**         parameter.
**     Parameters  :
**         NAME            - DESCRIPTION
**         Addr            - Address to EEPROM
**         Data            - Data to write
**     Returns     :
**         ---             - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_SPEED - the bean does not work in the
**                           active speed mode 
**                           - ERR_BUSY - device is busy 
**                           - ERR_VALUE - verification of written data
**                           failed (read value does not match with
**                           written value) 
**                           - ERR_NOTAVAIL - other device-specific
**                           error 
**                           - ERR_RANGE - parameter Addr is out of range
** ===================================================================
*/
byte IEE1_SetByte(IEE1_TAddress Addr,byte Data)
{
  byte err;
  word Data16;
  IEE1_TAddress SecAddr;               /* EEPROM Sector address */

  if((Addr < IEE1_AREA_START) || (Addr > IEE1_AREA_END)) { /* Is given address out of EEPROM area array ? */
    return ERR_RANGE;                  /* If yes then error */
  }
  if(!FSTAT_CCIF) {                    /* Is reading from EEPROM possible? */
    return ERR_BUSY;                   /* If no then error */
  }
  if (*(Addr) == 65535) {              /* Is the word erased? */
    SecAddr = (IEE1_TAddress)((dword)Addr & 16777214); /* Aligned word address */
    if (((dword)Addr) & 1) {           /* Not Aligned word ? */
      return(WriteWord(SecAddr, ((*SecAddr) & 65280) | Data));
    } else {
      return(WriteWord(Addr, (Data << 8) | (*(((byte *far)Addr) + 1)))); /* Aligned word ? */
    }
  } else {                             /* Is given address non-erased ? */
    SecAddr = (IEE1_TAddress)((dword)Addr & 16776960); /* Sector Aligned address */
    BackupSector(SecAddr, 0, 256);     /* Backup sector */
    Data16 = BackupArray[(((dword)Addr) % 256) / 2]; /* Store new data to backup array*/
    if (((dword)Addr) & 1) {           /* Not Aligned word ? */
      Data16 = (Data16 & 65280) | Data;
    } else {
      Data16 = (Data << 8) | (Data16 & 255);
    }
    BackupArray[(((dword)Addr) % 256) / 2] = Data16; /* Write new data to saved sector */
    err = EraseSectorInternal(Addr);   /* Erase sector */
    if(err) {
      return(err);                     /* Return error code if previous operation finished not correctly */
    }
    err = WriteBlock(SecAddr, 0, 256,BackupArray); /* Restore sector */
    return(err);
  }
}

/*
** ===================================================================
**     Method      :  IEE1_GetByte (bean IntEEPROM)
**
**     Description :
**         This method reads a byte from a specified EEPROM address.
**         The method also sets address pointer for <SetActByte> and
**         <GetActByte> methods (applicable only if these methods are
**         enabled). The pointer is set to address passed as the
**         parameter.
**     Parameters  :
**         NAME            - DESCRIPTION
**         Addr            - EEPROM Address
**       * Data            - A pointer to the returned 8-bit data
**     Returns     :
**         ---             - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_BUSY - device is busy 
**                           - ERR_RANGE - parameter Addr is out of range
** ===================================================================
*/
byte IEE1_GetByte(IEE1_TAddress Addr,byte *Data)
{
  if((Addr < IEE1_AREA_START) || (Addr > IEE1_AREA_END)) { /* Is given address out of EEPROM area array ? */
    return ERR_RANGE;                  /* If yes then error */
  }
  if(!FSTAT_CCIF) {                    /* Is reading from EEPROM possible? */
    return ERR_BUSY;                   /* If no then error */
  }
  *Data = *((byte *far)Addr);
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  IEE1_Init (bean IntEEPROM)
**
**     Description :
**         Initializes the associated peripheral(s) and the bean internal 
**         variables. The method is called automatically as a part of the 
**         application initialization code.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void IEE1_Init(void)
{
  FCLKDIV = 15;                        /* Set up Clock Divider Register */
}

/* END IEE1. */

/*
** ###################################################################
**
**     This file was created by UNIS Processor Expert 3.00 [04.12]
**     for the Freescale HCS12X series of microcontrollers.
**
** ###################################################################
*/
